<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC IP Camera Stream</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #f2f2f2;
    }
    h2, h3 {
      text-align: center;
    }
    .video-container {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    video, img {
      width: 360px;
      height: 240px;
      background: #000;
      border: 2px solid #ccc;
      border-radius: 8px;
      object-fit: cover;
    }
    .status {
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
      font-family: monospace;
    }
    button {
      background: #0078ff;
      color: #fff;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      border-radius: 6px;
    }
    button:hover {
      background: #005ec9;
    }
  </style>
</head>
<body>
  <h2>ðŸ“¡ WebRTC IP Camera Stream</h2>

  <div class="video-container">
    <div>
      <h3>Local Stream (IP Camera)</h3>
      <img id="ipCamImage" src="" alt="IP Camera Stream">
    </div>
    <div>
      <h3>Remote Stream (Receiver)</h3>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <div style="text-align:center; margin-bottom: 20px;">
    <label>Peer ID: </label>
    <input type="text" id="peerId" value="IPCam-Sender">
    <button id="connectBtn">Connect & Stream</button>
  </div>

  <h3>Status Log</h3>
  <div id="statusLog" class="status"></div>

  <script>
    const ipCamUrl = "https://10.210.14.58:8080/video"; // Replace with your IP camera URL
    const ipCamImage = document.getElementById("ipCamImage");
    const remoteVideo = document.getElementById("remoteVideo");
    const peerIdInput = document.getElementById("peerId");
    const connectBtn = document.getElementById("connectBtn");
    const statusLog = document.getElementById("statusLog");

    let ws, peerConnection;

    // Logging helper
    function log(msg, isError = false) {
      const div = document.createElement("div");
      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      if (isError) div.style.color = "red";
      statusLog.appendChild(div);
      statusLog.scrollTop = statusLog.scrollHeight;
      console.log(msg);
    }

    // Keep reloading IP camera snapshots
    function startIPCamera() {
      ipCamImage.src = `${ipCamUrl}?time=${Date.now()}`;
      ipCamImage.onload = () => setTimeout(startIPCamera, 100);
      ipCamImage.onerror = () => {
        log("âš ï¸ Failed to load IP camera frame. Retrying...");
        setTimeout(startIPCamera, 2000);
      };
    }

    async function createFakeVideoStreamFromCanvas() {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 640;
      canvas.height = 480;

      const stream = canvas.captureStream(15); // 15 FPS
      log("ðŸ–¼ï¸ Creating virtual video stream from IP camera...");

      const drawFrame = () => {
        ctx.drawImage(ipCamImage, 0, 0, canvas.width, canvas.height);
        requestAnimationFrame(drawFrame);
      };
      drawFrame();

      return stream;
    }

    connectBtn.onclick = async () => {
      const peerId = peerIdInput.value.trim();
      if (!peerId) {
        log("âŒ Enter a valid Peer ID", true);
        return;
      }

      startIPCamera();
      const localStream = await createFakeVideoStreamFromCanvas();

      const protocol = window.location.protocol === "https:" ? "wss://" : "ws://";
      const wsUrl = `${protocol}${window.location.host}`;
      ws = new WebSocket(wsUrl);

      ws.onopen = async () => {
        log("âœ… Connected to signaling server");
        ws.send(`NEWPEER|${peerId}|ALL|New IP camera stream|0|true`);

        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        peerConnection = new RTCPeerConnection(config);

        // Add IP camera video track
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.onicecandidate = e => {
          if (e.candidate) {
            const candidateObj = {
              sdpMid: e.candidate.sdpMid,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              candidate: e.candidate.candidate
            };
            ws.send(`CANDIDATE|${peerId}|ALL|${JSON.stringify(candidateObj)}`);
          }
        };

        peerConnection.onconnectionstatechange = () => {
          log(`ðŸ”„ Connection state: ${peerConnection.connectionState}`);
        };

        peerConnection.ontrack = event => {
          remoteVideo.srcObject = event.streams[0];
          log("ðŸŽ¥ Remote video stream received");
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        ws.send(`OFFER|${peerId}|ALL|${JSON.stringify({ type: "offer", sdp: offer.sdp })}`);
        log("ðŸ“¤ Sent offer to all clients");
      };

      ws.onmessage = async event => {
        const [type, senderId, , msgContent] = event.data.split("|");
        if (senderId === peerId) return;

        switch (type) {
          case "NEWPEER":
            log(`ðŸ‘¤ New peer connected: ${senderId}`);
            break;

          case "OFFER":
            log(`ðŸ“¨ Received offer from ${senderId}`);
            const offerObj = JSON.parse(msgContent);

            const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
            peerConnection = new RTCPeerConnection(config);

            peerConnection.ontrack = event => {
              remoteVideo.srcObject = event.streams[0];
              log(`ðŸŽ¥ Receiving stream from ${senderId}`);
            };

            peerConnection.onicecandidate = e => {
              if (e.candidate) {
                const candidateObj = {
                  sdpMid: e.candidate.sdpMid,
                  sdpMLineIndex: e.candidate.sdpMLineIndex,
                  candidate: e.candidate.candidate
                };
                ws.send(`CANDIDATE|${peerId}|${senderId}|${JSON.stringify(candidateObj)}`);
              }
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription(offerObj));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            ws.send(`ANSWER|${peerId}|${senderId}|${JSON.stringify(answer)}`);
            log(`ðŸ“¤ Sent answer to ${senderId}`);
            break;

          case "ANSWER":
            const answerObj = JSON.parse(msgContent);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answerObj));
            log(`âœ… Answer applied from ${senderId}`);
            break;

          case "CANDIDATE":
            const candidateObj = JSON.parse(msgContent);
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidateObj));
            log(`ðŸ§Š ICE candidate added from ${senderId}`);
            break;

          default:
            log(`â„¹ï¸ Unknown message type: ${type}`);
            break;
        }
      };

      ws.onerror = (err) => log(`âŒ WebSocket error: ${err.message}`, true);
      ws.onclose = () => log("ðŸ”Œ WebSocket connection closed");
    };
  </script>
</body>
</html>
