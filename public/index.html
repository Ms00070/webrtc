<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Signaling Tester 1</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .video-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        video {
            width: 320px;
            height: 240px;
            background-color: #000;
            border: 1px solid #ccc;
        }
        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f8f8f8;
        }
        button {
            padding: 10px;
            cursor: pointer;
        }
        .status {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f0f0f0;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
        }
        .connected {
            color: green;
        }
        .disconnected {
            color: red;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebRTC Signaling Test Client</h1>
       
        <div class="video-container">
            <div>
                <h3>Local Video</h3>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div>
                <h3>Remote Video</h3>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>
       
        <div class="control-panel">
            <h3>Connection Controls</h3>
            <div>
                <label for="peerId">Your Peer ID:</label>
                <input type="text" id="peerId" value="WebClient-User1">
            </div>
            <div>
                <h4>Stream Source</h4>
                <div>
                    <input type="radio" id="cameraSource" name="streamSource" value="camera" checked>
                    <label for="cameraSource">Camera</label>
                    <input type="radio" id="fileSource" name="streamSource" value="file">
                    <label for="fileSource">Video File</label>
                </div>
                <div id="fileInputContainer" style="display: none; margin-top: 10px;">
                    <input type="file" id="videoFileInput" accept="video/mp4,video/webm,video/ogg">
                    <video id="fileVideo" style="display: none;" controls></video>
                </div>
            </div>
            <div>
                <button id="startStreamBtn">Start Stream</button>
                <button id="connectBtn" disabled>Connect to Signaling Server</button>
                <button id="disconnectBtn" disabled>Disconnect</button>
            </div>
            <div>
                <label for="dataMessage">Send Data:</label>
                <input type="text" id="dataMessage" placeholder="Enter message to send">
                <button id="sendDataBtn" disabled>Send</button>
            </div>
        </div>
       
        <div>
            <h3>Status Log</h3>
            <div id="statusLog" class="status"></div>
        </div>

        <div>
            <h3>Detection Log</h3>
            <div id="detectionLog" class="status"></div>
        </div>
    </div>
   
    <script>
        // DOM elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const fileVideo = document.getElementById('fileVideo');
        const peerIdInput = document.getElementById('peerId');
        const startStreamBtn = document.getElementById('startStreamBtn');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const dataMessageInput = document.getElementById('dataMessage');
        const sendDataBtn = document.getElementById('sendDataBtn');
        const statusLog = document.getElementById('statusLog');
        const cameraSourceRadio = document.getElementById('cameraSource');
        const fileSourceRadio = document.getElementById('fileSource');
        const fileInputContainer = document.getElementById('fileInputContainer');
        const videoFileInput = document.getElementById('videoFileInput');
        const detectionLog = document.getElementById('detectionLog');

        // WebRTC variables
        let localStream;
        const peerConnections = {}; // Use an object to store multiple peer connections
        let ws;
        let peerId;
       
        // Log messages to status div
        function log(message, isError = false) {
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (isError) {
                logEntry.style.color = 'red';
            }
            statusLog.appendChild(logEntry);
            statusLog.scrollTop = statusLog.scrollHeight;
        }
       
        // Handle stream source selection
        cameraSourceRadio.addEventListener('change', () => {
            if (cameraSourceRadio.checked) {
                fileInputContainer.style.display = 'none';
            }
        });
       
        fileSourceRadio.addEventListener('change', () => {
            if (fileSourceRadio.checked) {
                fileInputContainer.style.display = 'block';
            }
        });
       
        // Handle video file selection
        videoFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                fileVideo.src = url;
                fileVideo.onloadedmetadata = () => {
                    log(`Loaded video: ${file.name} (${Math.round(file.size / 1024 / 1024)}MB)`);
                };
            }
        });
       
        // Start stream (either camera or video file)
        startStreamBtn.addEventListener('click', async () => {
            try {
                if (cameraSourceRadio.checked) {
                    // Start camera stream
                    localStream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: true
                    });
                    localVideo.srcObject = localStream;
                    log('Camera started successfully');
                } else {
                    // Use video file as stream source
                    if (!videoFileInput.files[0]) {
                        log('Please select a video file first', true);
                        return;
                    }
                   
                    // Play the video and capture its stream
                    fileVideo.style.display = 'block';
                    await fileVideo.play();
                    localStream = fileVideo.captureStream();
                    localVideo.srcObject = localStream;
                    log(`Streaming video file: ${videoFileInput.files[0].name}`);
                }
               
                startStreamBtn.disabled = true;
                connectBtn.disabled = false;
            } catch (error) {
                log(`Error starting stream: ${error.message}`, true);
            }
        });
       
        // Connect to signaling server
        connectBtn.addEventListener('click', () => {
            peerId = peerIdInput.value.trim();
            if (!peerId) {
                log('Please enter a valid Peer ID', true);
                return;
            }
           
            // Get WebSocket URL (use current page's hostname and port)
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const wsUrl = `${protocol}${window.location.host}`;
           
            log(`Connecting to signaling server at ${wsUrl}...`);
            ws = new WebSocket(wsUrl);
           
            ws.onopen = () => {
                log('Connected to signaling server', false);
                // Send NEWPEER message to announce ourselves
                ws.send(`NEWPEER|${peerId}|ALL|New web client peer|0|true`);
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                sendDataBtn.disabled = false;
            };
           
            ws.onclose = () => {
                log('Disconnected from signaling server', true);
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                sendDataBtn.disabled = true;
                cleanupAllConnections();
            };
           
            ws.onerror = (error) => {
                log(`WebSocket error: ${error.message}`, true);
            };
           
            ws.onmessage = (event) => {
                handleSignalingMessage(event.data);
            };
        });
       
        // Disconnect from signaling server
        disconnectBtn.addEventListener('click', () => {
            if (ws) {
                // Send DISPOSE message
                ws.send(`DISPOSE|${peerId}|ALL|Client disconnecting|0|false`);
                ws.close();
            }
            cleanupAllConnections();
            connectBtn.disabled = !localStream;
            disconnectBtn.disabled = true;
            sendDataBtn.disabled = true;
        });
       
        // Send data channel message
        sendDataBtn.addEventListener('click', () => {
            const message = dataMessageInput.value.trim();
            if (message && dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(message);
                log(`Sent data: ${message}`);
                dataMessageInput.value = '';
            }
        });
       
        function updateDetectionLog(detections) {
            // Clear previous detections
            detectionLog.innerHTML = '';

            if (detections && detections.length > 0) {
                detections.forEach(det => {
                    const logEntry = document.createElement('div');
                    const box = det.box.join(', ');
                    logEntry.textContent = 
                        `[${new Date().toLocaleTimeString()}] Detected: ${det.class_name} ` +
                        `(Conf: ${det.confidence.toFixed(2)}) at [${box}]`;
                    detectionLog.appendChild(logEntry);
                });
            } else {
                const logEntry = document.createElement('div');
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] No detections in this frame.`;
                detectionLog.appendChild(logEntry);
            }
            // Auto-scroll to the bottom
            detectionLog.scrollTop = detectionLog.scrollHeight;
        }
        // Handle incoming signaling messages
        function handleSignalingMessage(message) {
            // Parse message format: TYPE|SENDER_ID|RECEIVER_ID|MESSAGE|CONNECTION_COUNT|IS_VIDEO_AUDIO_SENDER
            const parts = message.split('|');
            const type = parts[0];
            const senderId = parts[1];
            const receiverId = parts[2];
            const msgContent = parts[3];
           
            // Ignore messages not intended for us
            if (receiverId !== peerId && receiverId !== 'ALL') {
                return;
            }
           
            log(`Received ${type} from ${senderId}`);
           
            switch (type) {
                case 'NEWPEER':
                case 'NEWPEERACK':
                    // When a new peer joins, create a connection to them
                    if (senderId !== peerId) {
                        createPeerConnection(senderId);
                    }
                    break;
                   
                case 'OFFER':
                    if (senderId !== peerId) {
                        handleOffer(senderId, JSON.parse(msgContent));
                    }
                    break;
                   
                case 'ANSWER':
                    if (senderId !== peerId) {
                        handleAnswer(senderId, JSON.parse(msgContent));
                    }
                    break;
                   
                case 'CANDIDATE':
                    if (senderId !== peerId) {
                        handleCandidate(senderId, JSON.parse(msgContent));
                    }
                    break;
                case 'DETECTION_DATA':
                    if (senderId !== peerId) {
                        const data = JSON.parse(msgContent);
                        updateDetectionLog(data.detections);
                    }
                    break;
                case 'DISPOSE':
                    if (senderId !== peerId) {
                        log(`Peer ${senderId} disconnected`);
                        cleanupPeerConnection(senderId);
                    }
                    break;
                   
                default:
                    log(`Unknown message type: ${type}`);
                    break;
            }
        }
       
        // Create RTCPeerConnection for a specific peer
        function createPeerConnection(remotePeerId) {
            if (peerConnections[remotePeerId]) {
                log(`Connection with ${remotePeerId} already exists.`);
                return;
            }
            log(`Creating connection with ${remotePeerId}`);

            const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
            const pc = new RTCPeerConnection(configuration);
            peerConnections[remotePeerId] = pc;

            // Add local media tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }

            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidateObj = {
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        candidate: event.candidate.candidate
                    };
                    ws.send(`CANDIDATE|${peerId}|${remotePeerId}|${JSON.stringify(candidateObj)}|0|true`);
                }
            };

            // Handle connection state changes
            pc.oniceconnectionstatechange = () => {
                log(`ICE connection state for ${remotePeerId}: ${pc.iceConnectionState}`);
                if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'closed') {
                    cleanupPeerConnection(remotePeerId);
                }
            };

            // Handle remote tracks (for receiving video)
            pc.ontrack = (event) => {
                log(`Received remote track from ${remotePeerId}`);
                // Display the first remote video found
                if (!remoteVideo.srcObject) {
                    remoteVideo.srcObject = event.streams[0];
                }
            };

            // Log when the connection is established
            pc.onconnectionstatechange = () => {
                log(`Connection state with ${remotePeerId}: ${pc.connectionState}`);
                if (pc.connectionState === 'connected') {
                    log(`Log: Video stream is sending to ${remotePeerId}.`);
                }
                if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'closed') {
                    cleanupPeerConnection(remotePeerId);
                }
            };

            // Create and send offer
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .then(() => {
                    const offerObj = {
                        type: 'offer',
                        sdp: pc.localDescription.sdp
                    };
                    ws.send(`OFFER|${peerId}|${remotePeerId}|${JSON.stringify(offerObj)}|0|true`);
                    log(`Sent offer to ${remotePeerId}`);
                })
                .catch(error => log(`Error creating offer for ${remotePeerId}: ${error.message}`, true));
        }
       
       
        // Handle incoming offer
        async function handleOffer(senderId, offerObj) {
            let pc = peerConnections[senderId];
            if (!pc) {
                log(`Received offer from unknown peer ${senderId}, creating connection.`);
                createPeerConnection(senderId);
                pc = peerConnections[senderId];
            }

            try {
                await pc.setRemoteDescription(new RTCSessionDescription(offerObj));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                const answerObj = {
                    type: 'answer',
                    sdp: pc.localDescription.sdp
                };
                ws.send(`ANSWER|${peerId}|${senderId}|${JSON.stringify(answerObj)}|0|false`);
                log(`Sent answer to ${senderId}`);
            } catch (error) {
                log(`Error handling offer from ${senderId}: ${error.message}`, true);
            }
        }
       
        // Handle incoming answer
        async function handleAnswer(senderId, answerObj) {
            const pc = peerConnections[senderId];
            if (!pc) {
                log(`Received answer from unknown peer: ${senderId}`, true);
                return;
            }
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answerObj));
                log(`Processed answer from ${senderId}`);
            } catch (error) {
                log(`Error handling answer from ${senderId}: ${error.message}`, true);
            }
        }
       
        // Handle incoming ICE candidate
        async function handleCandidate(senderId, candidateObj) {
            const pc = peerConnections[senderId];
            if (!pc) {
                log(`Received candidate from unknown peer: ${senderId}`, true);
                return;
            }
            try {
                if (candidateObj.candidate) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidateObj));
                }
            } catch (error) {
                log(`Error handling ICE candidate from ${senderId}: ${error.message}`, true);
            }
        }
       
       
        // Clean up a specific peer connection
        function cleanupPeerConnection(remotePeerId) {
            const pc = peerConnections[remotePeerId];
            if (pc) {
                pc.close();
                delete peerConnections[remotePeerId];
                log(`Cleaned up connection for ${remotePeerId}`);
            }

            // If no remote videos are being displayed, clear the video element
            if (Object.keys(peerConnections).length === 0) {
                remoteVideo.srcObject = null;
            }
        }

        function cleanupAllConnections() {
            Object.keys(peerConnections).forEach(id => cleanupPeerConnection(id));
            remoteVideo.srcObject = null;
            // Reset UI
            connectBtn.disabled = !localStream;
            disconnectBtn.disabled = true;
        }
       
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(`DISPOSE|${peerId}|ALL|Client disconnecting|0|false`);
            }
           
            // Clean up any object URLs to avoid memory leaks
            if (fileVideo.src.startsWith('blob:')) {
                URL.revokeObjectURL(fileVideo.src);
            }
        });
    </script>
</body>
</html>
