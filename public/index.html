<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>SFU Stream Viewer</title>
</head>
<body>
<h2>Mobile Camera Stream via SFU</h2>
<video id="remoteVideo" autoplay playsinline controls width="640"></video>

  <script>
    // DOM Elements
    const peerId = document.getElementById('peerId');
    const modeSelect = document.getElementById('mode');
    const cameraSource = document.getElementById('cameraSource');
    const fileSource = document.getElementById('fileSource');
    const videoFileInput = document.getElementById('videoFileInput');
    const fileVideo = document.getElementById('fileVideo');
    const localVideo = document.getElementById('localVideo');
    const remoteVideos = document.getElementById('remoteVideos');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const startStreamBtn = document.getElementById('startStreamBtn');
    const stopStreamBtn = document.getElementById('stopStreamBtn');
    const dataMessage = document.getElementById('dataMessage');
    const sendDataBtn = document.getElementById('sendDataBtn');
    const statusLog = document.getElementById('statusLog');
    const broadcasterList = document.getElementById('broadcasterList');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    // WebRTC Variables
    let localStream;
    let ws;
    let currentPeerId;
    let peerConnections = {};
    let dataChannels = {};
    let subscribedTo = new Set();
    let isBroadcaster = false;
    
    // Handle tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
      });
    });
    
    // Set up event listeners
    modeSelect.addEventListener('change', () => {
      if (modeSelect.value === 'broadcaster') {
        document.querySelector('.tab[data-tab="broadcaster"]').style.display = 'block';
        document.querySelector('.tab[data-tab="viewer"]').style.display = 'none';
      } else {
        document.querySelector('.tab[data-tab="broadcaster"]').style.display = 'none';
        document.querySelector('.tab[data-tab="viewer"]').style.display = 'block';
      }
    });
    
    connectBtn.addEventListener('click', connectToSignalingServer);
    disconnectBtn.addEventListener('click', disconnect);
    startStreamBtn.addEventListener('click', startBroadcasting);
    stopStreamBtn.addEventListener('click', stopBroadcasting);
    sendDataBtn.addEventListener('click', sendDataMessage);
    
    // Utility functions
    function log(message, isError = false) {
      const entry = document.createElement('div');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      if (isError) entry.style.color = 'red';
      statusLog.appendChild(entry);
      statusLog.scrollTop = statusLog.scrollHeight;
      console.log(message);
    }
    
    // Helper function to check and fix remote videos
    function checkAndFixRemoteVideo() {
      for (const broadcasterId of subscribedTo) {
        const videoEl = document.getElementById(`remote-video-${broadcasterId}`);
        if (videoEl && (!videoEl.srcObject || videoEl.srcObject.getTracks().length === 0) && peerConnections[broadcasterId]) {
          const pc = peerConnections[broadcasterId];
          const receivers = pc.getReceivers();
          
          if (receivers.length > 0) {
            const stream = new MediaStream();
            receivers.filter(r => r.track).forEach(r => stream.addTrack(r.track));
            
            if (stream.getTracks().length > 0) {
              videoEl.srcObject = stream;
              videoEl.play().catch(e => log(`Error playing video: ${e}`, true));
              log(`Fixed video display for ${broadcasterId}`);
            }
          }
        }
      }
    }
    
    // Connection functions
    function connectToSignalingServer() {
      currentPeerId = peerId.value.trim() || `WebClient-${Date.now()}`;
      const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsUrl = `${protocol}${window.location.host}`;
      
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        log('Connected to signaling server');
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        startStreamBtn.disabled = false;
        
        ws.send(`NEWPEER|${currentPeerId}|ALL|${modeSelect.value}|0|${modeSelect.value === 'broadcaster'}`);
        
        if (modeSelect.value === 'broadcaster') {
          ws.send(`BROADCAST_REGISTER|${currentPeerId}|ALL|New broadcaster available|0|true`);
          isBroadcaster = true;
        }
        
        setInterval(checkAndFixRemoteVideo, 3000);
      };
      
      ws.onclose = () => {
        log('Disconnected from signaling server', true);
        cleanupWebRTC();
      };
      
      ws.onmessage = (event) => handleSignalingMessage(event.data);
    }

    function disconnect() {
      if (ws) {
        ws.send(`DISPOSE|${currentPeerId}|ALL|Remove peerConnection for ${currentPeerId}.|0|false`);
        ws.close();
      }
      cleanupWebRTC();
    }
    
    function cleanupWebRTC() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      for (const peerId in peerConnections) {
        if (peerConnections[peerId]) {
          peerConnections[peerId].close();
        }
      }
      
      peerConnections = {};
      dataChannels = {};
      subscribedTo.clear();
      
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
      startStreamBtn.disabled = true;
      stopStreamBtn.disabled = true;
      sendDataBtn.disabled = true;
      localVideo.srcObject = null;
      remoteVideos.innerHTML = '';
      broadcasterList.innerHTML = '<p>No broadcasters available. Connect to server first.</p>';
    }
    
    async function startBroadcasting() {
      try {
        if (cameraSource.checked) {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        } else {
          if (!videoFileInput.files[0]) {
            log('Please select a video file first', true);
            return;
          }
          fileVideo.style.display = 'none';
          await fileVideo.play();
          localStream = fileVideo.captureStream();
        }
        
        localVideo.srcObject = localStream;
        startStreamBtn.disabled = true;
        stopStreamBtn.disabled = false;
        sendDataBtn.disabled = false;
        
        if (!isBroadcaster && ws.readyState === WebSocket.OPEN) {
          ws.send(`BROADCAST_REGISTER|${currentPeerId}|ALL|New broadcaster available|0|true`);
          isBroadcaster = true;
        }
      } catch (err) {
        log(`Error starting stream: ${err.message}`, true);
      }
    }
    
    function stopBroadcasting() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
        localStream = null;
      }
      
      startStreamBtn.disabled = false;
      stopStreamBtn.disabled = true;
      sendDataBtn.disabled = true;
    }
    
    function handleSignalingMessage(message) {
      const parts = message.split('|');
      if (parts.length < 4) return;
      
      const type = parts[0];
      const senderId = parts[1];
      const receiverId = parts[2];
      const content = parts[3];
      
      if (receiverId !== currentPeerId && receiverId !== 'ALL') return;
      
      switch (type) {
        case 'NEWPEER':
        case 'BROADCAST_AVAILABLE':
          if (senderId !== currentPeerId && (parts[5] === 'true' || content.includes('broadcaster'))) {
            handleBroadcasterAvailable(senderId);
          }
          break;
        case 'SUBSCRIBER_JOINED':
        case 'SUBSCRIBE':
          if (isBroadcaster && senderId !== currentPeerId) {
            createPeerConnectionForSubscriber(senderId);
          }
          break;
        case 'OFFER':
          handleOffer(senderId, content);
          break;
        case 'ANSWER':
          handleAnswer(senderId, content);
          break;
        case 'CANDIDATE':
          handleCandidate(senderId, content);
          break;
        case 'DISPOSE':
          removePeerConnection(senderId);
          break;
      }
    }
    
    function handleBroadcasterAvailable(broadcasterId) {
      if (broadcasterId === currentPeerId || modeSelect.value !== 'viewer') return;
      
      const existingBroadcaster = document.getElementById(`broadcaster-${broadcasterId}`);
      if (!existingBroadcaster) {
        if (broadcasterList.querySelector('p')) {
          broadcasterList.innerHTML = '';
        }
        
        const broadcasterDiv = document.createElement('div');
        broadcasterDiv.id = `broadcaster-${broadcasterId}`;
        broadcasterDiv.className = 'broadcaster';
        broadcasterDiv.style.padding = '10px';
        broadcasterDiv.style.marginBottom = '5px';
        broadcasterDiv.style.backgroundColor = '#e9f5ff';
        broadcasterDiv.style.borderRadius = '4px';
        broadcasterDiv.style.display = 'flex';
        broadcasterDiv.style.justifyContent = 'space-between';
        broadcasterDiv.style.alignItems = 'center';
        
        broadcasterDiv.innerHTML = `
          <div>${broadcasterId}</div>
          <button class="subscribe-btn" data-broadcaster-id="${broadcasterId}">Subscribe</button>
        `;
        broadcasterList.appendChild(broadcasterDiv);
        
        const subscribeBtn = broadcasterDiv.querySelector('.subscribe-btn');
        subscribeBtn.addEventListener('click', () => {
          const bId = subscribeBtn.dataset.broadcasterId;
          if (subscribedTo.has(bId)) {
            unsubscribeFromBroadcaster(bId);
            subscribeBtn.textContent = 'Subscribe';
          } else {
            subscribeTobroadcaster(bId);
            subscribeBtn.textContent = 'Unsubscribe';
          }
        });
      }
    }
    
    function subscribeTobroadcaster(broadcasterId) {
      if (subscribedTo.has(broadcasterId)) return;
      
      subscribedTo.add(broadcasterId);
      ws.send(`SUBSCRIBE|${currentPeerId}|${broadcasterId}|Subscribing to broadcast|0|false`);
      
      if (!peerConnections[broadcasterId]) {
        createPeerConnectionForBroadcaster(broadcasterId);
      }
    }
    
    function unsubscribeFromBroadcaster(broadcasterId) {
      if (!subscribedTo.has(broadcasterId)) return;
      
      subscribedTo.delete(broadcasterId);
      removePeerConnection(broadcasterId);
      
      const videoEl = document.getElementById(`remote-container-${broadcasterId}`);
      if (videoEl) videoEl.remove();
    }
    
    function createPeerConnectionForBroadcaster(broadcasterId) {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });
      
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(`CANDIDATE|${currentPeerId}|${broadcasterId}|${JSON.stringify(event.candidate)}`);
        }
      };
      
      pc.ontrack = (event) => {
        let container = document.getElementById(`remote-container-${broadcasterId}`);
        let videoEl = document.getElementById(`remote-video-${broadcasterId}`);
        
        if (!container) {
          container = document.createElement('div');
          container.id = `remote-container-${broadcasterId}`;
          container.className = 'video-container';
          
          videoEl = document.createElement('video');
          videoEl.id = `remote-video-${broadcasterId}`;
          videoEl.autoplay = true;
          videoEl.playsInline = true;
          
          const label = document.createElement('div');
          label.className = 'video-label';
          label.textContent = `Broadcaster: ${broadcasterId}`;
          
          container.appendChild(videoEl);
          container.appendChild(label);
          remoteVideos.appendChild(container);
        }
        
        if (!videoEl.srcObject) {
          videoEl.srcObject = new MediaStream();
        }
        
        videoEl.srcObject.addTrack(event.track);
        videoEl.play().catch(e => {});
      };
      
      const dc = pc.createDataChannel(`data-${broadcasterId}`);
      dataChannels[broadcasterId] = dc;
      
      peerConnections[broadcasterId] = pc;
      
      pc.createOffer()
        .then(offer => pc.setLocalDescription(offer))
        .then(() => {
          ws.send(`OFFER|${currentPeerId}|${broadcasterId}|${JSON.stringify({
            type: 'offer',
            sdp: pc.localDescription.sdp
          })}`);
        });
    }
    
    function createPeerConnectionForSubscriber(subscriberId) {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });
      
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(`CANDIDATE|${currentPeerId}|${subscriberId}|${JSON.stringify(event.candidate)}`);
        }
      };
      
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
      
      pc.ondatachannel = (event) => {
        dataChannels[subscriberId] = event.channel;
      };
      
      peerConnections[subscriberId] = pc;
      return pc;
    }
    
    function handleOffer(senderId, offerJson) {
      let pc = peerConnections[senderId];
      if (!pc) {
        pc = isBroadcaster ? 
          createPeerConnectionForSubscriber(senderId) : 
          createPeerConnectionForBroadcaster(senderId);
        
        if (!isBroadcaster) subscribedTo.add(senderId);
      }
      
      const offer = JSON.parse(offerJson);
      pc.setRemoteDescription(new RTCSessionDescription({
        type: 'offer',
        sdp: offer.sdp
      }))
        .then(() => {
          if (isBroadcaster && localStream) {
            const senders = pc.getSenders();
            if (senders.length === 0) {
              localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
              });
            }
          }
          return pc.createAnswer();
        })
        .then(answer => pc.setLocalDescription(answer))
        .then(() => {
          ws.send(`ANSWER|${currentPeerId}|${senderId}|${JSON.stringify({
            type: 'answer',
            sdp: pc.localDescription.sdp
          })}`);
        });
    }
    
    function handleAnswer(senderId, answerJson) {
      const pc = peerConnections[senderId];
      if (!pc) return;
      
      const answer = JSON.parse(answerJson);
      pc.setRemoteDescription(new RTCSessionDescription({
        type: 'answer',
        sdp: answer.sdp
      }));
    }
    
    function handleCandidate(senderId, candidateJson) {
      const pc = peerConnections[senderId];
      if (!pc) return;
      
      const candidate = JSON.parse(candidateJson);
      pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});
    }
    
    function removePeerConnection(peerId) {
      if (peerConnections[peerId]) {
        peerConnections[peerId].close();
        delete peerConnections[peerId];
      }
      
      if (dataChannels[peerId]) {
        delete dataChannels[peerId];
      }
      
      if (modeSelect.value === 'viewer') {
        const broadcasterEl = document.getElementById(`broadcaster-${peerId}`);
        if (broadcasterEl) broadcasterEl.remove();
        
        if (broadcasterList.children.length === 0) {
          broadcasterList.innerHTML = '<p>No broadcasters available. Connect to server first.</p>';
        }
        
        const videoEl = document.getElementById(`remote-container-${peerId}`);
        if (videoEl) videoEl.remove();
        
        subscribedTo.delete(peerId);
      }
    }
    
    function sendDataMessage() {
      const message = dataMessage.value.trim();
      if (!message) return;
      
      if (isBroadcaster) {
        for (const peerId in dataChannels) {
          const channel = dataChannels[peerId];
          if (channel && channel.readyState === 'open') {
            channel.send(message);
          }
        }
      } else {
        for (const broadcasterId of subscribedTo) {
          const channel = dataChannels[broadcasterId];
          if (channel && channel.readyState === 'open') {
            channel.send(message);
          }
        }
      }
      
      dataMessage.value = '';
    }

    document.querySelector('.tab[data-tab="viewer"]').style.display = 'none';
  </script>
</body>
</html>
