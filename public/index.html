<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC IP Camera Stream</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .video-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
    }
    video, img {
      width: 360px;
      height: 240px;
      background: #000;
      border: 1px solid #ccc;
      border-radius: 5px;
      object-fit: cover;
    }
    .status {
      font-family: monospace;
      background: #f7f7f7;
      border: 1px solid #ccc;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h2>WebRTC IP Camera Stream</h2>
  <div class="video-container">
    <div>
      <h3>Local Stream (IP Camera)</h3>
      <!-- For IP webcam, we use an <img> tag -->
      <img id="ipCamImage" src="" alt="IP Camera Stream">
    </div>
    <div>
      <h3>Remote Stream (Receiver)</h3>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <div>
    <label>Peer ID:</label>
    <input type="text" id="peerId" value="IPCam-Sender">
    <button id="connectBtn">Connect & Stream</button>
  </div>

  <h3>Status</h3>
  <div id="statusLog" class="status"></div>

  <script>
    const ipCamUrl = "http://10.210.14.58:8080/video"; // Replace with your IP webcam stream URL
    const ipCamImage = document.getElementById("ipCamImage");
    const remoteVideo = document.getElementById("remoteVideo");
    const peerIdInput = document.getElementById("peerId");
    const connectBtn = document.getElementById("connectBtn");
    const statusLog = document.getElementById("statusLog");

    let ws, peerConnection, dataChannel;

    function log(msg, isError = false) {
      const div = document.createElement("div");
      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      if (isError) div.style.color = "red";
      statusLog.appendChild(div);
      statusLog.scrollTop = statusLog.scrollHeight;
      console.log(msg);
    }

    // Keep reloading the IP camera snapshot (MJPEG not always supported directly)
    function startIPCamera() {
      ipCamImage.src = `${ipCamUrl}?time=${Date.now()}`;
      ipCamImage.onload = () => {
        setTimeout(startIPCamera, 100);
      };
      ipCamImage.onerror = () => {
        log("Failed to load IP camera stream. Retrying...");
        setTimeout(startIPCamera, 2000);
      };
    }

    async function createFakeVideoStreamFromCanvas() {
      // Create a canvas and draw IP cam frames on it continuously
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 640;
      canvas.height = 480;

      const stream = canvas.captureStream(15); // 15 FPS
      log("Converting IP camera to video stream...");

      const drawFrame = () => {
        ctx.drawImage(ipCamImage, 0, 0, canvas.width, canvas.height);
        requestAnimationFrame(drawFrame);
      };
      drawFrame();
      return stream;
    }

    connectBtn.onclick = async () => {
      const peerId = peerIdInput.value.trim();
      if (!peerId) {
        log("Enter a Peer ID", true);
        return;
      }

      startIPCamera();

      log("Fetching IP camera and starting WebRTC...");
      const localStream = await createFakeVideoStreamFromCanvas();

      // Setup WebSocket
      const protocol = window.location.protocol === "https:" ? "wss://" : "ws://";
      const wsUrl = `${protocol}${window.location.host}`;
      ws = new WebSocket(wsUrl);

      ws.onopen = async () => {
        log("Connected to signaling server");
        ws.send(`NEWPEER|${peerId}|ALL|New IP camera stream|0|true`);

        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        peerConnection = new RTCPeerConnection(config);

        // Add IP camera stream to WebRTC
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });

        peerConnection.onicecandidate = e => {
          if (e.candidate) {
            const candidateObj = {
              sdpMid: e.candidate.sdpMid,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              candidate: e.candidate.candidate
            };
            ws.send(`CANDIDATE|${peerId}|ALL|${JSON.stringify(candidateObj)}`);
          }
        };

        peerConnection.onconnectionstatechange = () => {
          log(`ICE state: ${peerConnection.iceConnectionState}`);
        };

        peerConnection.ontrack = event => {
          log("Received remote track");
          remoteVideo.srcObject = event.streams[0];
        };

        // Create offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        const offerObj = { type: "offer", sdp: offer.sdp };
        ws.send(`OFFER|${peerId}|ALL|${JSON.stringify(offerObj)}`);
        log("Offer sent to all clients");
      };

      ws.onmessage = async event => {
        const [type, senderId, , msgContent] = event.data.split("|");
        if (senderId === peerId) return;

        switch (type) {
          case "ANSWER":
            const answerObj = JSON.parse(msgContent);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answerObj));
            log("Answer received and applied");
            break;

          case "CANDIDATE":
            const candidateObj = JSON.parse(msgContent);
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidateObj));
            log("Candidate added");
            break;
        }
      };
    };
  </script>
</body>
</html>
