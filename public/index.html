<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Signaling Tester</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .video-container {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    video {
      width: 320px;
      height: 240px;
      background-color: #000;
      border: 1px solid #ccc;
    }
    .control-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f8f8f8;
    }
    button {
      padding: 10px;
      cursor: pointer;
    }
    .status {
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f0f0f0;
      height: 200px;
      overflow-y: auto;
      font-family: monospace;
    }
    .connected {
      color: green;
    }
    .disconnected {
      color: red;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebRTC Signaling Test Client</h1>
    
    <div class="video-container">
      <div>
        <h3>Local Video</h3>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      <div>
        <h3>Remote Video</h3>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>
    
    <div class="control-panel">
      <h3>Connection Controls</h3>
      <div>
        <label for="peerId">Your Peer ID:</label>
        <input type="text" id="peerId" value="WebClient-User1">
      </div>
      <div>
        <h4>Stream Source</h4>
        <div>
          <input type="radio" id="cameraSource" name="streamSource" value="camera" checked>
          <label for="cameraSource">Camera</label>
          <input type="radio" id="fileSource" name="streamSource" value="file">
          <label for="fileSource">Video File</label>
        </div>
        <div id="fileInputContainer" style="display: none; margin-top: 10px;">
          <input type="file" id="videoFileInput" accept="video/mp4,video/webm,video/ogg">
          <video id="fileVideo" style="display: none;" controls></video>
        </div>
      </div>
      <div>
        <button id="startStreamBtn">Start Stream</button>
        <button id="connectBtn" disabled>Connect to Signaling Server</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
      </div>
      <div>
        <label for="dataMessage">Send Data:</label>
        <input type="text" id="dataMessage" placeholder="Enter message to send">
        <button id="sendDataBtn" disabled>Send</button>
      </div>
    </div>
    
    <div>
      <h3>Status Log</h3>
      <div id="statusLog" class="status"></div>
    </div>
  </div>

  <script>
    // DOM elements
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const fileVideo = document.getElementById('fileVideo');
    const peerIdInput = document.getElementById('peerId');
    const startStreamBtn = document.getElementById('startStreamBtn');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const dataMessageInput = document.getElementById('dataMessage');
    const sendDataBtn = document.getElementById('sendDataBtn');
    const statusLog = document.getElementById('statusLog');
    const cameraSourceRadio = document.getElementById('cameraSource');
    const fileSourceRadio = document.getElementById('fileSource');
    const fileInputContainer = document.getElementById('fileInputContainer');
    const videoFileInput = document.getElementById('videoFileInput');
    
    // WebRTC variables
    let localStream;
    let peerConnection;
    let dataChannel;
    let ws;
    let peerId;

    // Log helper
    function log(message, isError = false) {
      const logEntry = document.createElement('div');
      logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      if (isError) logEntry.style.color = 'red';
      statusLog.appendChild(logEntry);
      statusLog.scrollTop = statusLog.scrollHeight;
    }

    // Handle stream source selection
    cameraSourceRadio.addEventListener('change', () => {
      if (cameraSourceRadio.checked) fileInputContainer.style.display = 'none';
    });
    fileSourceRadio.addEventListener('change', () => {
      if (fileSourceRadio.checked) fileInputContainer.style.display = 'block';
    });

    // File selection
    videoFileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const url = URL.createObjectURL(file);
        fileVideo.src = url;
        fileVideo.onloadedmetadata = () => {
          log(`Loaded video: ${file.name} (${Math.round(file.size / 1024 / 1024)}MB)`);
        };
      }
    });

    // Start stream manually
    startStreamBtn.addEventListener('click', async () => {
      await startStream();
    });

    // === Function to start stream (camera by default) ===
    async function startStream() {
      try {
        if (cameraSourceRadio.checked) {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          localVideo.srcObject = localStream;
          log('Camera started successfully');
        } else {
          if (!videoFileInput.files[0]) {
            log('Please select a video file first', true);
            return;
          }
          fileVideo.style.display = 'block';
          await fileVideo.play();
          localStream = fileVideo.captureStream();
          localVideo.srcObject = localStream;
          log(`Streaming video file: ${videoFileInput.files[0].name}`);
        }
        startStreamBtn.disabled = true;
        connectBtn.disabled = false;
      } catch (error) {
        log(`Error starting stream: ${error.message}`, true);
      }
    }

    // Connect manually
    connectBtn.addEventListener('click', () => {
      initConnection();
    });

    // Disconnect manually
    disconnectBtn.addEventListener('click', () => {
      if (ws) {
        ws.send(`DISPOSE|${peerId}|ALL|Remove peerConnection for ${peerId}.|0|false`);
        ws.close();
      }
      cleanupRTCConnection();
      connectBtn.disabled = !localStream;
      disconnectBtn.disabled = true;
      sendDataBtn.disabled = true;
    });

    // Send data
    sendDataBtn.addEventListener('click', () => {
      const message = dataMessageInput.value.trim();
      if (message && dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(message);
        log(`Sent data: ${message}`);
        dataMessageInput.value = '';
      }
    });

    // Init connection
    function initConnection() {
      peerId = peerIdInput.value.trim() || `WebClient-${Date.now()}`;
      const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsUrl = `${protocol}${window.location.host}`;

      log(`Connecting to signaling server at ${wsUrl}...`);
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        log('Connected to signaling server');
        ws.send(`NEWPEER|${peerId}|ALL|New web client peer|0|true`);
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        sendDataBtn.disabled = false;
      };

      ws.onclose = () => {
        log('Disconnected from signaling server', true);
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        sendDataBtn.disabled = true;
        cleanupRTCConnection();
      };

      ws.onerror = (error) => log(`WebSocket error: ${error.message}`, true);
      ws.onmessage = (event) => handleSignalingMessage(event.data);
    }

    // --- WebRTC Handlers ---
    function handleSignalingMessage(message) {
      const parts = message.split('|');
      const type = parts[0];
      const senderId = parts[1];
      const receiverId = parts[2];
      const msgContent = parts[3];

      if (receiverId !== peerId && receiverId !== 'ALL') return;

      log(`Received ${type} from ${senderId}`);

      switch (type) {
        case 'NEWPEER':
        case 'NEWPEERACK':
          if (!peerConnection) createPeerConnection(senderId);
          break;
        case 'OFFER':
          if (senderId !== peerId) handleOffer(senderId, msgContent);
          break;
        case 'ANSWER':
          if (senderId !== peerId) handleAnswer(senderId, msgContent);
          break;
        case 'CANDIDATE':
          if (senderId !== peerId) handleCandidate(senderId, msgContent);
          break;
        case 'DISPOSE':
          if (senderId !== peerId) {
            log(`Peer ${senderId} disconnected`);
            cleanupRTCConnection();
          }
          break;
        default:
          log(`Unknown message type: ${type}`);
      }
    }

    function createPeerConnection(remotePeerId) {
      log(`Creating connection with ${remotePeerId}`);
      const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
      peerConnection = new RTCPeerConnection(configuration);

      dataChannel = peerConnection.createDataChannel('dataChannel');
      setupDataChannel(dataChannel);

      if (localStream) {
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
      }

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          const candidateObj = {
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            candidate: event.candidate.candidate
          };
          ws.send(`CANDIDATE|${peerId}|${remotePeerId}|${JSON.stringify(candidateObj)}`);
        }
      };

      peerConnection.oniceconnectionstatechange = () => log(`ICE state: ${peerConnection.iceConnectionState}`);
      peerConnection.ontrack = (event) => {
        log('Received remote track');
        remoteVideo.srcObject = event.streams[0];
      };
      peerConnection.ondatachannel = (event) => {
        log('Received data channel');
        setupDataChannel(event.channel);
      };

      createOffer(remotePeerId);
    }

    async function createOffer(remotePeerId) {
      try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        const offerObj = { type: 'offer', sdp: peerConnection.localDescription.sdp };
        ws.send(`OFFER|${peerId}|${remotePeerId}|${JSON.stringify(offerObj)}`);
        log(`Sent offer to ${remotePeerId}`);
      } catch (err) {
        log(`Error creating offer: ${err.message}`, true);
      }
    }

    async function handleOffer(senderId, offerMessage) {
      try {
        const offerObj = JSON.parse(offerMessage);
        if (!peerConnection) createPeerConnection(senderId);
        await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: offerObj.sdp }));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        const answerObj = { type: 'answer', sdp: peerConnection.localDescription.sdp };
        ws.send(`ANSWER|${peerId}|${senderId}|${JSON.stringify(answerObj)}`);
        log(`Sent answer to ${senderId}`);
      } catch (err) {
        log(`Error handling offer: ${err.message}`, true);
      }
    }

    async function handleAnswer(senderId, answerMessage) {
      try {
        const answerObj = JSON.parse(answerMessage);
        await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: answerObj.sdp }));
        log(`Processed answer from ${senderId}`);
      } catch (err) {
        log(`Error handling answer: ${err.message}`, true);
      }
    }

    async function handleCandidate(senderId, candidateMessage) {
      try {
        const candidateObj = JSON.parse(candidateMessage);
        if (candidateObj.candidate) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidateObj));
        }
      } catch (err) {
        log(`Error handling ICE candidate: ${err.message}`, true);
      }
    }

    function setupDataChannel(channel) {
      channel.onopen = () => { log('Data channel opened'); sendDataBtn.disabled = false; };
      channel.onclose = () => { log('Data channel closed'); sendDataBtn.disabled = true; };
      channel.onmessage = (e) => log(`Received data: ${e.data}`);
      channel.onerror = (e) => log(`Data channel error: ${e.message}`, true);
    }

    function cleanupRTCConnection() {
      if (peerConnection) { peerConnection.close(); peerConnection = null; }
      if (dataChannel) { dataChannel.close(); dataChannel = null; }
      remoteVideo.srcObject = null;
      startStreamBtn.disabled = false;
      connectBtn.disabled = true;
    }

    // Dispose on unload
    window.addEventListener('beforeunload', () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(`DISPOSE|${peerId}|ALL|Remove peerConnection for ${peerId}.|0|false`);
      }
      if (fileVideo.src.startsWith('blob:')) URL.revokeObjectURL(fileVideo.src);
    });

    // === Auto Start & Connect on Page Load ===
    window.addEventListener('load', async () => {
      await startStream();     // Start camera automatically
      initConnection();        // Connect automatically
    });
  </script>
</body>
</html>
