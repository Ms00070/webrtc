<!DOCTYPE html>
<html>
<head>
  <title>WebRTC MP4 Stream</title>
  <style>
    #log {
      border: 1px solid #ccc;
      padding: 10px;
      height: 200px;
      overflow-y: scroll;
      font-family: monospace;
      background: #f9f9f9;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    video {
      max-width: 100%;
      border: 1px solid #333;
    }
    button {
      padding: 8px 16px;
      margin: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>Upload MP4 and Stream to Unity</h2>
  <div>
    <input type="file" id="fileInput" accept="video/mp4">
    <button id="startButton">Start Streaming</button>
    <button id="announceButton">Announce Ready</button>
  </div>
  <video id="localVideo" autoplay controls playsinline muted></video>
  <h3>Logs</h3>
  <div id="log"></div>
 
  <script>
    // Log helper function
    function logOnScreen(msg) {
      const logDiv = document.getElementById("log");
      logDiv.innerHTML += msg + "<br>";
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(msg);
    }
   
    // Map to store pending ICE candidates until remote description is set
    const pendingIceCandidates = new Map();
    
    // WebSocket connection
    const ws = new WebSocket("wss://webrtc-9gdy.onrender.com/");
    const peers = {};
    let localStream;
    const clientId = "WebClient-" + Date.now();
   
    // Handle WebSocket open
    ws.onopen = () => {
      logOnScreen("Connected to custom WSS server");
      // Send NEWPEER in Unity format
      const newPeerMsg = `NEWPEER|${clientId}|ALL|New peer ${clientId}|0|true`;
      ws.send(newPeerMsg);
      logOnScreen(`Sent: ${newPeerMsg}`);
    };
   
    // Handle WebSocket messages
    ws.onmessage = async (event) => {
      const msgStr = event.data;
      logOnScreen("Received: " + msgStr);
      
      try {
        // Try to parse as Unity format first (TYPE|SENDER_ID|...)
        if (msgStr.includes('|')) {
          const parts = msgStr.split('|');
          const type = parts[0];
          const senderId = parts[1];
          const receiverId = parts[2];
          const message = parts[3];
          
          // Handle OFFER
          if (type === 'OFFER' && receiverId === clientId) {
            logOnScreen(`Received offer from ${senderId}`);
            handleUnityOffer(senderId, message);
          }
          
          // Handle ICE candidates
          if (type === 'CANDIDATE' && receiverId === clientId) {
            logOnScreen(`Received ICE candidate from ${senderId}`);
            handleUnityCandidate(senderId, message);
          }
          
          // Handle direct messages
          if (type === 'MESSAGE' && (receiverId === clientId || receiverId === 'ALL')) {
            logOnScreen(`Message from ${senderId}: ${message}`);
            
            // Handle video requests
            if (message === 'request-video' || message.includes('request-video')) {
              if (localStream) {
                logOnScreen(`Sending video stream to ${senderId}`);
                createPeerConnectionForUnity(senderId);
              } else {
                logOnScreen("Video request received but no local stream available");
              }
            }
          }
        } else {
          // Try to parse as JSON
          const data = JSON.parse(msgStr);
          
          // Handle welcome message
          if (data.type === 'welcome') {
            logOnScreen(`Received welcome with client ID: ${data.clientId}`);
          }
          
          // Handle other JSON messages as needed
        }
      } catch (err) {
        logOnScreen(`Error handling message: ${err.message}`);
      }
    };
    
    // Handle WebSocket errors and closure
    ws.onerror = (error) => {
      logOnScreen(`WebSocket error: ${error}`);
    };
    
    ws.onclose = () => {
      logOnScreen("WebSocket connection closed");
    };
    
    // Create peer connection for Unity client
    function createPeerConnectionForUnity(unityClientId) {
      logOnScreen(`Creating peer connection for Unity client: ${unityClientId}`);
      
      // Close existing connection if any
      if (peers[unityClientId]) {
        peers[unityClientId].close();
      }
      
      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" }
        ]
      });
      
      // Store the connection
      peers[unityClientId] = pc;
      
      // Add local tracks to the connection
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
      
      // Handle ICE candidate generation
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          // Format for Unity client
          const candidateJson = JSON.stringify(event.candidate);
          const candidateMsg = `CANDIDATE|${clientId}|${unityClientId}|${candidateJson}|0|false`;
          ws.send(candidateMsg);
          logOnScreen(`Sent ICE candidate to ${unityClientId}`);
        }
      };
      
      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        logOnScreen(`Connection state with ${unityClientId}: ${pc.connectionState}`);
      };
      
      // Create and send offer
      pc.createOffer()
        .then(offer => pc.setLocalDescription(offer))
        .then(() => {
          const offerMsg = `OFFER|${clientId}|${unityClientId}|${pc.localDescription.sdp}|0|true`;
          ws.send(offerMsg);
          logOnScreen(`Sent offer to ${unityClientId}`);
        })
        .catch(error => {
          logOnScreen(`Error creating offer: ${error}`);
        });
      
      return pc;
    }
    
    // Handle offer from Unity client
    async function handleUnityOffer(senderId, offerSdp) {
      try {
        const pc = createPeerConnection(senderId, true);
        
        // Set remote description first
        const offer = new RTCSessionDescription({ type: 'offer', sdp: offerSdp });
        await pc.setRemoteDescription(offer);
        logOnScreen(`Set remote description from ${senderId}`);
        
        // Create and set local answer
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        // Send answer back to Unity client
        const answerMsg = `ANSWER|${clientId}|${senderId}|${answer.sdp}|0|false`;
        ws.send(answerMsg);
        logOnScreen(`Sent answer to ${senderId}`);
        
        // Process any pending ICE candidates for this peer
        const candidates = pendingIceCandidates.get(senderId) || [];
        logOnScreen(`Processing ${candidates.length} pending ICE candidates for ${senderId}`);
        
        for (const candidate of candidates) {
          try {
            await pc.addIceCandidate(candidate);
          } catch (e) {
            logOnScreen(`Error adding stored ICE candidate: ${e}`);
          }
        }
        
        // Clear the pending candidates
        pendingIceCandidates.delete(senderId);
      } catch (e) {
        logOnScreen(`Error handling offer: ${e}`);
      }
    }
    
    // Handle ICE candidate from Unity client
    async function handleUnityCandidate(senderId, candidateStr) {
      try {
        const pc = peers[senderId];
        if (!pc) {
          logOnScreen(`No peer connection for ${senderId} to add ICE candidate`);
          return;
        }
        
        const candidate = JSON.parse(candidateStr);
        
        // Check if remote description is set
        if (pc.remoteDescription && pc.remoteDescription.type) {
          // Remote description is set, add the candidate directly
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
          logOnScreen(`Added ICE candidate for ${senderId}`);
        } else {
          // Remote description not set yet, store the candidate
          if (!pendingIceCandidates.has(senderId)) {
            pendingIceCandidates.set(senderId, []);
          }
          pendingIceCandidates.get(senderId).push(new RTCIceCandidate(candidate));
          logOnScreen(`Stored ICE candidate for ${senderId} (waiting for remote description)`);
        }
      } catch (e) {
        logOnScreen(`Error handling ICE candidate: ${e}`);
      }
    }
    
    // Create peer connection (general function)
    function createPeerConnection(peerId, isUnity = false) {
      // Close existing connection if any
      if (peers[peerId]) {
        peers[peerId].close();
      }
      
      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" }
        ]
      });
      
      // Store the connection
      peers[peerId] = pc;
      
      // Add local tracks if available
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
      
      // Handle ICE candidate generation
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          if (isUnity) {
            // Format for Unity client
            const candidateJson = JSON.stringify(event.candidate);
            const candidateMsg = `CANDIDATE|${clientId}|${peerId}|${candidateJson}|0|false`;
            ws.send(candidateMsg);
            logOnScreen(`Sent ICE candidate to ${peerId}`);
          } else {
            // Format for browser client
            ws.send(JSON.stringify({
              type: "candidate",
              candidate: event.candidate,
              to: peerId
            }));
          }
        }
      };
      
      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        logOnScreen(`Connection state with ${peerId}: ${pc.connectionState}`);
      };
      
      return pc;
    }
    
    // File input handling
    document.getElementById('fileInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        logOnScreen(`Selected file: ${file.name}`);
        
        // Create a video URL from the file
        const videoUrl = URL.createObjectURL(file);
        const videoElement = document.getElementById('localVideo');
        videoElement.src = videoUrl;
        
        // Play the video once it's loaded
        videoElement.onloadedmetadata = () => {
          videoElement.play().catch(e => logOnScreen(`Error playing video: ${e}`));
        };
        
        // Capture stream from the video element
        videoElement.onplaying = () => {
          try {
            localStream = videoElement.captureStream();
            logOnScreen("Captured stream from video");
            logOnScreen("Ready to stream to Unity clients");
          } catch (e) {
            logOnScreen(`Error capturing stream: ${e}`);
          }
        };
      }
    });
    
    // Start streaming button
    document.getElementById('startButton').addEventListener('click', () => {
      if (!localStream) {
        logOnScreen("Please select a video file first");
        return;
      }
      
      // Find connected Unity clients and send them the video
      Object.keys(peers).forEach(peerId => {
        if (peerId.startsWith('UnityClient')) {
          createPeerConnectionForUnity(peerId);
        }
      });
    });
    
    // Announce ready button
    document.getElementById('announceButton').addEventListener('click', () => {
      if (!localStream) {
        logOnScreen("Please select a video file first");
        return;
      }
      
      // Send ready message to all clients
      const readyMsg = `MESSAGE|${clientId}|ALL|sender-ready|0|true`;
      ws.send(readyMsg);
      logOnScreen("Announced sender-ready to all clients");
    });
  </script>
</body>
</html>
